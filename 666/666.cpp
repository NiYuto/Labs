// 666.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
////Описать класс, реализующий стек и работу с ним.
//1.)	Класс должен содержать следующие сведения о книгах в библиотеке :
//•	фамилию и инициалы автора;
//•	название;
//•	год издания;
//•	количество экземпляров данной книги в библиотеке.
//2.)	В классе должны быть реализованы следующие операции над стеком :
//•	добавление данных о книгах вновь поступивших в библиотеку;
//•	удаление данных о списываемой книге, название которой введено с клавиатуры;
//•	вывод информации обо всех книгах в библиотеке;
//•	по запросу выводится информация обо всех книгах автора, имеющихся в библиотеке, чья фамилия введена с клавиатуры.
//3.)	Программа должна обеспечивать диалог с помощью меню.
//4.)	В программе должны быть созданы два экземпляра класса : книги в библиотеке и выданные читателям.
//Когда читатель берет книгу в библиотеке, информация о ней(по введенному названию книги) должна быть 
//автоматически удалена из списка книг в библиотеке и переведена в список книг у читателей.
//Когда читатель сдает книгу в библиотеку, информация о ней должна быть автоматически удалена из списка книг 
//у читателей и перенесена в список книг в библиотеке.
//При выводе информации о книгах, пользователь должен выбрать какой список выводить(книги в библиотеке или у читателей), 
//либо вывести все книги из обоих списков.

#include <iostream>
#include <string>
#include <windows.h>
#include <iomanip>

using namespace std;

struct Node
{
    string Surname;//
    string Ini;//
    string Name;//
    int Year;//
    int Num;//
}L;

struct List
{
    Node data;
    List* next = nullptr;
};

class Stack
{
public:
    Stack();
    ~Stack();
    void Add(struct Node);//Добавление данных на 
    void Pop();//удаление верхнего элемента
    bool isEmpty() { return (head == NULL); }//если пусть, возвращает true/false при пустой/заполненой структуре
    void Output();//вывод информацию о всем стеке
    void Find(string mb);//найти по всей структуре и сравнить по фамилии
    void Info(List* current);//Вывод текущего значения  в лист структуре
    Node* StrucktReturn();//возврат текущего значения data для переноса в буффер
    void Delete();
private:
    List* head;//начало стека
};

Stack::Stack()//конструктор, начальное значение = ничему
{
    head = NULL;
}

Stack::~Stack()//деструктор, уничтожает структуру с головы
{
    while (!isEmpty())
    {
        Pop();
    }
}
void Stack::Add(struct Node q)//добавить элемент
{
    List* temp = new List();//создание нового лист структуры
    temp->data = q;//текущее значение структуры с данным
    temp->next = head;//указатель на голову
    head = temp;
}

void Stack::Pop()//удаляет верхний элемент стека
{
    if (isEmpty())
    {
        cout << "Стек пуст\n";
        return;
    }
    else
    {
        Node data = head->data;
        List* old = head;
        head = old->next;
        delete old;
    }
}

Node* Stack::StrucktReturn()
{
    List* Ltemp = head;
    Node* Ntemp;
    Ntemp = &Ltemp->data;
    return Ntemp;
}

void Stack::Delete()
{

}

void Stack::Output()//вывод всех данных из стека
{
    List* current = head;
    cout << setw(20) << left << "=Автор="
        << setw(20) << left << "=Инициалы=";
    cout << setw(20) << left << "=Название=";
    cout << setw(20) << left << "=Год издания=";
    cout << setw(20) << left << "=Кол-во экземпляров=" << endl;
    while (current)//пока есть текущее
    {
        Info(current);
        current = current->next;//текущее=следующему элементу
    }
    system("pause");
}

void Stack::Find(string mb)
{
    List* current = head;
    cout << setw(20) << left << "=Автор="
        << setw(20) << left << "=Инициалы=";
    cout << setw(20) << left << "=Название=";
    cout << setw(20) << left << "=Год издания=";
    cout << setw(20) << left << "=Кол-во экземпляров=" << endl;
    while (current)
    {
        if (current->data.Surname == mb)
        {
            Info(current);
        }
        current = current->next;
    }
    system("pause");
}


void Stack::Info(List* current)//вывод информации из текущего указателя
{
    
    cout << setw(20) << left << current->data.Surname
        << setw(20) << left << current->data.Ini;
    cout << setw(20) << left << current->data.Name;
    cout << setw(20) << left << current->data.Year;
    cout << setw(20) << left << current->data.Num << endl;
    cout << endl;
}

void Book(Stack* one /*из которого беруться книги*/, Stack* two /*куда кладуться книги*/, Stack* Buff/*временный буффер для книг*/, string find, Node* t)
{
    int check;
    while (!one->isEmpty())
    {

        t = one->StrucktReturn(); //буфферное структура Node, в которую временно записываются
        //данные, которые запишутся в другой временный стек
        if (t->Name != find)
        {
            Buff->Add(*t);           //добавление в буффер данных сверху вниз(в обратном порядке, потом при обратном
            //добавлении он опять развернеться и будет как надо
            one->Pop();             //удаление верхнего элемента из оригинального стека
        }
        else
        {
            cout << setw(20) << left << "=Автор="
                << setw(20) << left << "=Инициалы=";
            cout << setw(20) << left << "=Название=";
            cout << setw(20) << left << "=Год издания=";
            cout << setw(20) << left << "=Кол-во экземпляров=" << endl;
            cout << setw(20) << left << t->Surname
                << setw(20) << left << t->Ini;
            cout << setw(20) << left << t->Name;
            cout << setw(20) << left << t->Year;
            cout << setw(20) << left << t->Num << endl;
            cout << "------------------------------------------------------------------\n";
            cout << "Выдать или вернуть эту книгу? 1.Да 2.Нет\n";
            while (!(cin >> check))
            {
                cin.clear();
                cin.ignore(cin.rdbuf()->in_avail());
                cout << "Введите число\n";
            }
            if (check == 1)
            {
                two->Add(*t);//добавление в другую структуру
                one->Pop();//удаление из первой структуры
                //Отказывается добавляться сюда bad_alloc
                cout << "Книги успешно выданы или получены \n";
            }
            else
            {
                cout << "Отмена\n";
                Buff->Add(*t);//в буффер добавляется текущий элемент
                one->Pop();//удалениче из первой структуры
            }
        }
    }
    //После того, как буффер готов, нужно перезаписать данные из него обратно в стек;
    while (!Buff->isEmpty())
    {
        t = Buff->StrucktReturn();
        one->Add(*t);//восстановление структуры с учетом перенесенных книг
        Buff->Pop();//отчистка буффера для последующей работы;
    }
    system("pause");
}


//////////////////////////////////////////////

////////////////////////////////////////////
int main()
{
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);
    Stack In;
    Stack Out;
    Stack Buff;
    Node* t = new Node;
    List* q = new List;
    string mb = "";
    int check = 0;
    bool a = true;
    while (a == true)
    {
        system("cls");
        cout << "/----------------------------------------/\n";
        cout << "     Главное меню\n";
        cout << "1. Добавить книги в библеотеку\n";//готово
        cout << "2. Списать книгу\n";//готово
        cout << "3. Вывод информации о всех книгах\n";//готово
        cout << "4. Поиск книг автора\n";//готово
        cout << "5. Выдача книг\n";//
        cout << "6. Возврат книг в библиотеку\n";//
        cout << "7. Закончить работу\n";
        cout << "/----------------------------------------/\n";
        cout << "   Введите номер: ";
        cin >> check;
        switch (check)
        {
        case 1:
        {
            while (check == 1)
            {
                Node* k = new Node;
                cout << "фамилия ";
                cin.ignore();
                getline(cin, k->Surname);
                cout << "Инициалы ";
                getline(cin, k->Ini);
                cout << "Название ";
                getline(cin, k->Name);
                cout << "Год ";
                while (!(cin >> k->Year))
                {
                    cin.clear();
                    cin.ignore(cin.rdbuf()->in_avail());
                    cout << "Введите число\n";
                }
                cout << "Кол-во экземпляров ";
                while (!(cin >> k->Num))
                {
                    cin.clear();
                    cin.ignore(cin.rdbuf()->in_avail());
                    cout << "Введите число\n";
                }
                In.Add(*k);
                cout << "Повторить ввод 1.Да 2.Нет \n";
                cin >> check;
                delete k;
            }
            system("pause");
            break;
        }
        case 2://
        {
            if (In.isEmpty())
            {
                cout << "Стек пуст\n";
                system("pause");
            }
            else
            {
                cout << "/----------------------------------------/\n";
                cout << "Введите название книги, которую хотите списать: ";
                cin.ignore();
                getline(cin, mb);//Получаем название строки, которую хотим удалить
                while (!In.isEmpty())
                {
                    
                    t = In.StrucktReturn();//буфферное структура Node, в которую временно записываются
                    //данные, которые запишутся в другой временный стек
                    if (t->Name != mb)
                    {
                        Buff.Add(*t);           //добавление в буффер данных сверху вниз(в обратном порядке, потом при обратном
                                                //добавлении он опять развернеться и будет как надо
                        In.Pop();               //удаление верхнего элемента из оригинального стека
                    }
                    else
                    {
                        cout << setw(20) << left << "=Автор="
                            << setw(20) << left << "=Инициалы=";
                        cout << setw(20) << left << "=Название=";
                        cout << setw(20) << left << "=Год издания=";
                        cout << setw(20) << left << "=Кол-во экземпляров=" << endl;
                        cout << setw(20) << left << t->Surname
                            << setw(20) << left << t->Ini;
                        cout << setw(20) << left << t->Name;
                        cout << setw(20) << left << t->Year;
                        cout << setw(20) << left << t->Num << endl;
                        cout<<"------------------------------------------------------------------\n";
                        cout << "Списать эти книги? 1.Да 2.Нет\n";
                        while (!(cin >> check))
                        {
                            cin.clear();
                            cin.ignore(cin.rdbuf()->in_avail());
                            cout << "Введите число\n";
                        }
                        if (check==1)
                        {
                            In.Pop();
                            cout << "Книги успешно удалены \n";
                        }
                        else
                        {
                            cout << "Отмена\n";
                            Buff.Add(*t);
                            In.Pop();
                        }
                        
                    }                    
            }//После того, как буффер готов, нужно перезаписать данные из него обратно в стек;
                /*In.~Stack();
                Stack In;*/
            while (!Buff.isEmpty())
            {
                t = Buff.StrucktReturn();
                In.Add(*t);
                Buff.Pop();//отчистка буффера для последующей работы;
            }
            system("pause");
            }
            break;
        }
        case 3:
        {
            if ((In.isEmpty()) && (Out.isEmpty()))
            {
                cout << "Список в библиотеке пуст\n";
                system("pause");
            }
            else
            {
                cout << "О каких книгах вывести информацию 1. Для книг в библиотке 2. Для книг у читателей 3. Все книги\n";
                while (!(cin >> check))
                {
                    cin.clear();
                    cin.ignore(cin.rdbuf()->in_avail());
                    cout << "Введите число\n";
                }
                if (check == 1)
                {
                    cout << "Книги в библеотеке\n";
                    In.Output();
                }
                else if (check == 2)
                {
                    cout << "Книги у читателей\n";
                    Out.Output();
                }
                else
                {
                    cout << "Книги в библеотеке\n";
                    In.Output();
                    cout << "-------------------------------------------------------\n";
                    cout << "Книги у читателей\n";
                    Out.Output();
                }

            }
            break;
        }
        case 4:
        {
            cout << "/----------------------------------------/\n";
            cout << "             Поиск книг автора\n";
            cout << "/----------------------------------------/\n";
            cout << "Введите фамилию автора: ";
            cin.ignore();
            getline(cin, mb);
            cout << "/----------------------------------------/\n";
            cout << "  Список всех книг автора в библиотеке\n";
            In.Find(mb);
            break;
        }
        case 5:
        {
            if (In.isEmpty())
            {
                cout << "Стек пуст\n";
                system("pause");
            }
            else
            {
                cout << "/----------------------------------------/\n";
                cout << "Введите название книги, которую хотите выдать: ";
                cin.ignore();
                getline(cin, mb);//Получаем название строки, которую хотим удалить
                Book(&In, &Out, &Buff, mb, t);
            }
            break;
        }
        case 6:
        {
            if (In.isEmpty())
            {
                cout << "Стек пуст\n";
                system("pause");
            }
            else
            {
                cout << "/----------------------------------------/\n";
                cout << "Введите название книги, которую хотите вернуть: ";
                cin.ignore();
                getline(cin, mb);//Получаем название строки, которую хотим удалить
                Book(&Out, &In, &Buff, mb, t);
            }
            break;
        }
        case 7:
        {
            In.~Stack();
            Out.~Stack();
            Buff.~Stack();
            delete t;
            a = false;
            break;
        }
        default:
            cout << "Некоректно введено значение, повторите попытку";
            break;
        }
    }
    return 0;
}

// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
